<!DOCTYPE html>
<html>
  <head>
    <title>INFO 450 - Week 9</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
      body 
      { font-family: 'Droid Serif'; }

      
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code, .remark-inline-code { font-size: 14px; }
      i {
          color: #0000FF;
      }
/* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
/* Two-column layout */
      .left-column-half {
        color: #777;
        width: 50%;
        height: 92%;
        float: left;
      }
      .right-column-half {
        width: 50%;
        float: right;
        padding-top: 1em;
        line-height: .9em;
      }

      table {
        width: 100%;
        border: 2px solid black;
        }
        table, th, td {
           border: 1px solid black;
        }


    .remark-code{
      font-size:14px;
    }
    table, td, th {
        border: 1px solid black;
        font-size: .9em;
    }
    code {
      white-space : pre-wrap !important;
      font-size: .9em;
    }
    .remark-code {
      font-size: 12px;
    }

    quote {
      font-style: italic;

     }
    </style>
  </head>
  <body>
    <textarea id="source" class: center, middle >

# INFO 450 Fall 2020
<div style="text-align:center;font-size: 1.5;line-height:1.8em;">Week 9</div>
<div style="text-align:center;font-size: 1.5;line-height:1.8em;">March 30, 2021</div>
 
---
# Agenda


1. Exam Review
2. Data structures
3. Big O / Complexity
4. Sorting


---
# Exam Review

---
# Data Structure

List

Queues

Stacks
---
# Lists


* Linear list of objects/values.

* Size of the list is unknown, vs an array of a fixed size.

* We covered these extensively


```python
my_list = []
my_list.append("one")
my_list.append(2)
my_list.append("foo")

for x in my_list:
    print(x)
```

---
# Queue

Standing in line at a roller coaster.

First in, first out   (FIFO)

## This is a slow implementation, but using concepts we know already

```python

my_queue = []
my_queue.append("first")
my_queue.append("second")
my_queue.append("third")
my_queue.append("fourth")


print(my_queue.popleft())
print(my_queue.popleft())
print(my_queue.popleft())
print(my_queue.popleft())

```
---
# Better implementation

Professor note: pronunced 'deck', double ended queue

Collections package, deque object

```python
from collections import deque
queue = deque()
queue.append("first in")
queue.append("second in")
queue.append("third in")

print(queue.popleft())
print(queue.popleft())
print(queue.popleft())
```

---
# Stack

First in, Last Out (FILO)

Last In, First Out (LIFO)

* Coins in the car coin slot holder.

* Text editor, undo function

```python

my_stack = []
my_stack.append("first in")
my_stack.append("second in")
my_stack.append("third in")

print(my_stack.pop())
print(my_stack.pop())
print(my_stack.pop())

```

Traditional methods for stacks:  push, pop


---
# Big O 

Complexity of an algorithm

We use Big-O notation to asymptotically bound the growth of a running time to within constant factors above and below. Sometimes we want to bound from only above.

Asymptotic: so defined that their ratio approaches unity as the independent variable approaches a limit or infinity. (CHF: I liked this one the best)

What the heck does this mean?
In programming, we measure the efficiency of an algorithm on a collection of data, in relation to the number of items in the collection.

---
# Example 

Consider a sorting algorithm on an array:

```python
my_numbers = [5,1,6,3,2]
```

There are 5 elements in the array.  

We write a sorting algorithm that puts them in the correct order, and it takes 5 units of time.  

(computers are fast, so this could be 5 \* 100 nanoseconds, 5 \* 1 second, whatever.   

That is why we talk about "units of time".


---
# Now what?

```python
my_numbers = [5, 1, 6, 3, 2, 8, 3, 7, 8, 2]
```

Now we are up to 10 items in our array, or double the number of items.

We measure the efficiency of our algorithm by the units of time, or set of operations, that get executed dependant on the number of items in the array.

In this case, if the 10 elements take 10 units of time, then we know our algorithm has a linear relationship to the number of elements.  

This is labeled as  O(n).

Where O is the notation of complexity, and <strong>n</strong> represents the linear relationship.  

This is similar to plotting x=y on a graph. 

---
# Can it be worse?

Using the same 10 items in our array, if we plot the time to sort the algorith, and we see an exponential relationship, then we have a problem.

The Red line indicates O(n<sup>2</sup>)

<img src="bigochart.png" width="90%"/>

---
# List of Big O Complexities

<img src="bigo.png" width="100%"/>
Source: https://en.wikipedia.org/wiki/Big_O_notation

---
# Sorting

* Bubble Sort
* Selection Sort
* Merge Sort

---
# Bubble Sort
O(n^2)
<a href="https://www.youtube.com/watch?v=nmhjrI-aW5o" target="_blank">Video</a>

<a href='bubble.py'  target="_blank">Bubble Sort</a>

<a href="https://en.wikipedia.org/wiki/Bubble_sort" target="_blank">Wikipedia: Bubble Sort</a>


---
# Bubble Sort (code)

```python
import random

def bubble(inbound):
    outbound = inbound.copy()
    n = len(outbound)
    for i in range(n):
        for j in range(0, n - i - 1):
            if outbound[j] > outbound[j + 1]:
                outbound[j], outbound[j+1] = outbound[j + 1], outbound[j]

    return outbound

if __name__ == "__main__":
    my_list = []
    for x in range(20):
        my_list.append(random.randint(0, 1000))
    print(my_list)

    sorted_list = bubble(my_list)

    print(sorted_list)
```

---
# Selection Sort

O(n^2)

<a href="https://youtu.be/xWBP4lzkoyM" target="_blank">Video</a>

<a href="selection.py" target="_blank">Selection Sort</a>

<a href="https://en.wikipedia.org/wiki/Selection_sort">Wikipedia: Selection Sort</a>


---
# Selection Sort (Code)

```python
import random

def selection(inbound):
    outbound = inbound.copy()
    for i in range(len(outbound)):
        min_idx = i
        for j in range(i + 1, len(outbound)):
            if outbound[min_idx] > outbound[j]:
                min_idx = j
        outbound[i], outbound[min_idx] = outbound[min_idx], outbound[i]

    return outbound
  
if __name__ == "__main__":
    my_list = []
    for x in range(20):
        my_list.append(random.randint(0, 1000))
    print(my_list)

    sorted_list = selection(my_list)

    print(sorted_list)


```
---
# Recursion

<strong>Recursion</strong> is the process of defining something in terms of itself, circular definitions.

e.g. <i>A circle is defined as something circular in shape</i>

In programming (not just C++), recursion is the process of a function calling itself.

A function that calls itself is said to be <strong>recursive</strong>.

---
# Classic Factorial Example

The factorial of a number <i>N</i> is the product of all the whole numbers between <i>1</i> and <i>N</i>

For Example, 4 factorial is 1x2x3x4 = 24

Let's compare the 'iterative' implementation of factorial to the recursive implementation

---
# Iterative Implementation

```python

def fact(n):
    if n <= 0:
        raise Exception("Can't factorial a number less than 0")
    answer = 1
    for x in range(1, n + 1):
        answer *= x
    return answer

if __name__ == "__main__":
    for x in range(1, 21):
        print(f"Factorial of {x} is {fact(x)}")
```

<a href="fact.py" target="_blank">Iterative Factorial</a>
---
# Recursive Implementation

```python

def recursive_fact(n):
    if n <= 0:
        raise Exception("Can't factorial a number less than 0")
    if n == 1: 
        return n
    answer = recursive_fact(n - 1) * n
    return answer


if __name__ == "__main__":
    for x in range(1, 21):
        print(f"Recursive Factorial of {x} is {recursive_fact(x)}")
```

<a href="recursive_fact.py" target="_blank">Recursive Factorial</a>

---
# Breaking it down

recursive_fact is the function with an integer

```python
def recursive_fact(n):
```

Quick business rule, can't factorial a number less than 0

```python
if n <= 0:
    raise Exception("Can't factorial a number less than 0")
```

CRITICAL to <strong>ALWAYS</strong> have an 'exit' point of a recursive function, otherwise, you'll hit an infinite loop, blowing your stack

```python
if n == 1: 
    return n
```

The recursion. call factr with one less than n. Which will then call factr with another one less than n, until n is 1. Then, returns it to by multipled against the 'next' number

```python
answer = recursive_fact(n - 1) * n
```

Return the answer

```python
return answer
```

---
# Merge Sort

Divide and Conquer

O(n log n)

Better than O(n^2)

<a href="https://www.youtube.com/watch?v=JSceec-wEyw" target="_blank">Video</a>

<a href="merge.py" target="_blank">Merge Sort</a>

<a href="https://en.wikipedia.org/wiki/Merge_sort">Wikipedia: Merge Sort</a>

---
# Merge Sort

```python
import random

def merge_sort(inbound):
    if len(inbound) >1:
        mid = len(inbound)//2 # Finding the mid of the array
        left_array = inbound[:mid] # Dividing the array elements
        right_array = inbound[mid:] # into 2 halves

        merge_sort(left_array) # Sorting the first half
        merge_sort(right_array) # Sorting the second half

        i = j = k = 0

        # Copy data to temp arrays left_array[] and right_array[]
        while i < len(left_array) and j < len(right_array):
            if left_array[i] < right_array[j]:
                inbound[k] = left_array[i]
                i+= 1
            else:
                inbound[k] = right_array[j]
                j+= 1
            k+= 1

        # Checking if any element was left
        while i < len(left_array):
            inbound[k] = left_array[i]
            i+= 1
            k+= 1

        while j < len(right_array):
            inbound[k] = right_array[j]
            j+= 1
            k+= 1

if __name__ == '__main__':
    my_list = []
    for x in range(20):
        my_list.append(random.randint(0, 1000))
    print(my_list)

    merge_sort(my_list)

    print(my_list)
```
---
# Homework

Due next Monday night (April 6, 2020 by 11:59:59 PM, eastern)

In your github repository:

github.com/[account]/[repository]/spiral

The canvas submission will be the url to your code.

<img src="spiral.png" width="80%"/>


```
What is the sum of the numbers on the diagonals in a 501 by 501 spiral formed in the same way?

```

A project framework will be published within 24 hours for you to clone.. feel free to start thinking about solving your problem now.


---
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
